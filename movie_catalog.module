<?php

/**
 * Implements hook_cron_queue_info().
 */
function movie_catalog_cron_queue_info() {
  $queues['movie_catalog'] = array(
    'worker callback' => 'movie_catalog_process_queue_item',
    'time' => (int) variable_get('movie_catalog_process_time', 60),
  );

  return $queues;
}

/**
 * Perform action on each queue item.
 *
 * @param array $data
 *   An array containing source and target taxonomy term data
 *
 */
function movie_catalog_process_queue_item($data) {
  switch (strtolower($data['op'])) {
    case 'add':
        // Create new node.
        $node = new stdClass();
        $node->type = $data['type'];
        node_object_prepare($node);
        populate_node_data($node, $data);
      break;

    case 'update':
        $node = node_load($data['movie']->entity_id);
        populate_node_data($node, $data);
      break;

    default:
      // Invalid Action.
      drupal_set_message(t("Invalid operation: @op", array(
        '@op' => $data['op'],
      )));
      break;
  }
}

function populate_node_data($node, $data) {


  // Populate node values.
  if (isset($movie_data->title)) {
    $node->title = check_plain($movie_data->title);
  }
  $node->language = LANGUAGE_NONE;
  if (isset($movie_data->plot)) {
    $node->body[$node->language][0] = movie_catalog_prepare_field_body($movie_data->plot, 'filtered_html');
  }
  $node->field_imdb_id[$node->language][0]['value'] = $imdb_id;
  if (isset($movie_data->rating)) {
    $node->field_rating[$node->language][0]['value'] = check_plain($movie_data->rating);
  }
  // Genres (Autocomplete field).
  if (isset($movie_data->genres)) {
    $node->field_genres[$node->language] = movie_catalog_prepare_term_autocomplete('genres', $movie_data->genres);
  }
  if (isset($movie_data->cover)) {
    $node->field_cover_url[$node->language][0]['value'] = check_plain($movie_data->cover);
  }
  //$node->field_cover[$node->language] = movie_catalog_prepare_remote_image($movie_data->cover);
  $node->status = 1;
  $node->promote = 0;
  $node->comment = 0;

  // Term reference (taxonomy) field
  //$node->field_genres[$node->language][]['tid'] = $form_state['values']['a taxonomy term id'];

  // Entity reference field
  /*
  $node->field_customer_nid[$node->language][] = array(
    'target_id' => $form_state['values']['entity id'],
    'target_type' => 'node',
  );
  */
  // 'node' is default,

  node_submit($node);
  node_save($node);
}


/**
 * Helper to prepare value for body.
 *
 * @param $value
 * @param $format_id
 * @return array
 */
function movie_catalog_prepare_field_body($value, $format_id) {
  // Clean array.
  if (is_array($value)) {
    foreach ($value as $key => $item) {
      $value[$key] = '<p>' . check_markup($item, $format_id) . '</p>';
    }
    $value = implode("\n", $value);
  } else {
    $value = check_markup($value, $format_id);
  }

  return array(
    'value' => $value,
    'summary' => text_summary($value),
    'format' => $format_id,
  );
}

/**
 * Helper to populate Tids for multiple values autocomplete term reference field.
 *
 * @param $field_name
 * @param $vocab_name
 * @param $value
 */
function movie_catalog_prepare_term_autocomplete($vocab_name, $value) {
  $value = is_array($value)
    ? implode(',', $value)
    : $value;
  $value = check_plain($value);

  $vocabulary = taxonomy_vocabulary_machine_name_load($vocab_name);

  $values = array();
  foreach (drupal_explode_tags($value) as $term_entry) {
    // See if the term exists in the chosen vocabulary and return the tid;
    // otherwise, create a new 'autocreate' term for insert/update.
    if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($term_entry), 'vid' => $vocabulary->vid))) {
      $term = array_pop($possibilities);
    }
    else {
      $term = array(
        'tid' => 'autocreate',
        'vid' => $vocabulary->vid,
        'name' => $term_entry,
        'vocabulary_machine_name' => $vocabulary->machine_name,
      );
    }
    $values[] = (array)$term;
  }

  return $values;
}
